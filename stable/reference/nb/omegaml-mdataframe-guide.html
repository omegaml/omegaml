

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Working with MDataFrame &mdash; omega-ml 0.18.0-rc2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=7ca4e891" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=d809baae"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            omega-ml
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guide/index.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin/index.html">Deploying omega-ml</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devguide/index.html">Extending omega-ml</a></li>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../support.html">Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changes/index.html">Changes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">omega-ml</a>
      </nav>

      <div class="wy-nav-content">


        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Working with MDataFrame</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/reference/nb/omegaml-mdataframe-guide.ipynb.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Working-with-MDataFrame">
<h1>Working with MDataFrame<a class="headerlink" href="#Working-with-MDataFrame" title="Link to this heading">¶</a></h1>
<p>A short guide</p>
<section id="What-is-MDataFrame?">
<h2>What is MDataFrame?<a class="headerlink" href="#What-is-MDataFrame?" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MDataFrame</span></code> provides a Pandas-like API to omega-ml’s analytics storage (backed by MongoDB). The key thing about <code class="docutils literal notranslate"><span class="pre">MDataFrames</span></code> is that they represent the <em>description of data and processes applied to the data</em>, but do not contain data itself. In this sense <code class="docutils literal notranslate"><span class="pre">MDataFrame</span></code> is the same for MongoDB as SQL is for a relational database: a query language.</p></li>
<li><p>Like Pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>, <code class="docutils literal notranslate"><span class="pre">MDataFrame</span></code> provides convenient operations for querying, subsetting, and grouping data. The key difference is that while Pandas must always load all data into memory before operating on it, <code class="docutils literal notranslate"><span class="pre">MDataFrame</span></code> passes operations on to the database. The result of such operations is typically a Pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>, or another <code class="docutils literal notranslate"><span class="pre">MDataFrame</span></code>.</p></li>
<li><p>For cases where the we need more complex processing than the database supports, <code class="docutils literal notranslate"><span class="pre">MDataFrame</span></code> can run a Python function on the data in parallel.</p></li>
<li><p>Note that <code class="docutils literal notranslate"><span class="pre">MDataFrame</span></code> <em>is not</em> a drop-in replacement for Pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>.</p></li>
</ul>
</section>
<section id="Concepts">
<h2>Concepts<a class="headerlink" href="#Concepts" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MDataFrame</span></code>: reprents a columnar datastructure made of of columns and rows</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MSeries</span></code>: represents all values in a single column</p></li>
</ul>
<p>In addition there are several helpers that provide specific functionality, e.g. for positional access, slicing and group-by processing. We don’t specify the details of these helpers as they are tied into the MDataFrame and MSeries API.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">.value</span></code> resolves the result of all operations, e.g. filtering, slicing, aggregation to a local in-memory pandas dataframe (useful for exploratory tasks and groupby aggregation)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.apply()</span></code> provides in-database processing (e.g. filtering, slicing, aggregation)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.transform()</span></code> provides parallel out-of-core, chunk-by-chunk processing (use for large datasets)</p></li>
</ul>
</section>
<section id="Storing-data-as-an-MDataFrame">
<h2>Storing data as an MDataFrame<a class="headerlink" href="#Storing-data-as-an-MDataFrame" title="Link to this heading">¶</a></h2>
<p>You can store any of the following objects and return them as an MDataFrame:</p>
<ul class="simple">
<li><p>Pandas Dataframe (and any source that Pandas supports): <code class="docutils literal notranslate"><span class="pre">om.datasets.put(df,</span> <span class="pre">'name')</span></code></p></li>
<li><p>Any sql source supported by the (e.g. snowflake) <code class="docutils literal notranslate"><span class="pre">om.datasets.put('connstr',</span> <span class="pre">'name')</span></code></p></li>
<li><p>CSV files from an externally hosted source (ftp, http, s3): <code class="docutils literal notranslate"><span class="pre">om.datasets.put(None,</span> <span class="pre">'name',uri='http://....')</span></code></p></li>
<li><p>Any other tabular-like data that you insert into the analytics store (i.e. MongoDB): <code class="docutils literal notranslate"><span class="pre">om.datasets.put(docs,</span> <span class="pre">'name')</span></code></p></li>
</ul>
<p>Note in general the MDataFrame is not dependent on the original <em>source</em> of the data, but on the format it is stored in omega-ml’s analytics storage. As long as the data can be retrieved back and transformed to a format Pandas can work with, MDataFrame will be able to handle it. That said, it works easiest with tabular data of rows and columns where each cell has some scalar value.</p>
</section>
<section id="Getting-an-MDataFrame">
<h2>Getting an MDataFrame<a class="headerlink" href="#Getting-an-MDataFrame" title="Link to this heading">¶</a></h2>
<p>The following methods are equivalent, both return an instance of <code class="docutils literal notranslate"><span class="pre">MDataFrame</span></code></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mdf = om.datasets.getl(&#39;name&#39;)
mdf = om.datasets.get(&#39;name&#39;, lazy=True)
</pre></div>
</div>
<p>Using any of these methods, <code class="docutils literal notranslate"><span class="pre">mdf</span></code> will represent the <code class="docutils literal notranslate"><span class="pre">MDataFrame</span></code> instance. Note that this will return immediately as no data access happens at this time.</p>
<section id="Executing-a-query">
<h3>Executing a query<a class="headerlink" href="#Executing-a-query" title="Link to this heading">¶</a></h3>
<p>To actually get data from a MDataFrame you need to ask for evaluation. This will execute the query according to all operations applied so far. The result is a standard Pandas DataFrame:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mdf.value
</pre></div>
</div>
<p><strong>Note this can be a dangerous operation as it will load all the data into memory</strong> If the result of your query is larger than the available memory of your process, it will fail and result in an operating-system level out of memory condition. If you are unsure how many rows a query will return, try using <code class="docutils literal notranslate"><span class="pre">.count()</span></code> first.</p>
</section>
<section id="Persisting-the-result-of-a-query">
<h3>Persisting the result of a query<a class="headerlink" href="#Persisting-the-result-of-a-query" title="Link to this heading">¶</a></h3>
<p>To evaluate an MDataFrame without returning all data into memory, use the <code class="docutils literal notranslate"><span class="pre">.persist()</span></code> method</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mdf.persist(&#39;name&#39;, store=om.datasets)
</pre></div>
</div>
<p>This is the equivalent of <code class="docutils literal notranslate"><span class="pre">df</span> <span class="pre">=</span> <span class="pre">mdf.value;</span> <span class="pre">om.datasets.put(df,</span> <span class="pre">'name')</span></code>, however all operations are performed in the database, results are retrieved back to memory only if needed, and if so in small chunks.</p>
</section>
</section>
<section id="Slicing">
<h2>Slicing<a class="headerlink" href="#Slicing" title="Link to this heading">¶</a></h2>
<p>Like Pandas DataFrame, MDataFrame can be sliced</p>
<ul class="simple">
<li><p>by a set of columns: <code class="docutils literal notranslate"><span class="pre">mdf[['col1',</span> <span class="pre">'col2']]</span></code> =&gt; return a MDataFrame subset to col1, col2</p></li>
<li><p>by single columns <code class="docutils literal notranslate"><span class="pre">mdf['col1']</span></code> =&gt; return a MSeries</p></li>
<li><p>by rows <code class="docutils literal notranslate"><span class="pre">mdf.iloc[start:end]</span></code> =&gt; return a MDataFrame subset to rows with index start to end.</p></li>
<li><p>by index <code class="docutils literal notranslate"><span class="pre">mdf.loc[label]</span></code> =&gt; return a MDataFrame subset to columns with corresponding labels</p></li>
<li><p>by filter <code class="docutils literal notranslate"><span class="pre">mdf[filter-mask]</span></code>=&gt; return a MDataFrame subset to the filter mask</p></li>
</ul>
<p>Note that <code class="docutils literal notranslate"><span class="pre">.loc,</span> <span class="pre">.iloc</span></code> require the data to have been stored from a Pandas DataFrame.</p>
</section>
<section id="Filtering">
<h2>Filtering<a class="headerlink" href="#Filtering" title="Link to this heading">¶</a></h2>
<p><em>By filter masks</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>flt = mdf[&#39;column&#39;] == value  # use any operator supported by MSeries
mdf[flt]
</pre></div>
</div>
<p>Filtering can be done by using a combination of <code class="docutils literal notranslate"><span class="pre">keyword__&lt;operator&gt;=&lt;value</span></code></p>
</section>
<section id="Aggregation-and-transformation">
<h2>Aggregation and transformation<a class="headerlink" href="#Aggregation-and-transformation" title="Link to this heading">¶</a></h2>
<p>MDataFrame provides a powerful set of aggregations:</p>
<ul class="simple">
<li><p>in-database or local groupby processing <code class="docutils literal notranslate"><span class="pre">mdf.groupby</span></code></p></li>
<li><p>in-database transformation and aggregation <code class="docutils literal notranslate"><span class="pre">mdf.apply()</span></code></p></li>
<li><p>out-of-core parallel processing <code class="docutils literal notranslate"><span class="pre">mdf.transform()</span></code></p></li>
</ul>
<section id="In-database-transformations">
<h3>In-database transformations<a class="headerlink" href="#In-database-transformations" title="Link to this heading">¶</a></h3>
<p>Using <code class="docutils literal notranslate"><span class="pre">MDataFrame.apply()</span></code> we can apply several column-wise transformations. Note that the function passed to apply must accept an ApplyContext.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mdf.iloc[0:1000].apply(lambda v: {
    &#39;key&#39;      : v[&#39;l_orderkey&#39;],
    &#39;comment&#39;: v[&#39;l_comment&#39;].str.concat(&#39; *&#39;),
    &#39;docs&#39;: v[&#39;l_shipinstruct&#39;].str.usplit(&#39; &#39;),
    &#39;comment_lower&#39;: v[&#39;l_shipinstruct&#39;].str.lower(),
    &#39;comment_substr&#39;: v[&#39;l_shipinstruct&#39;].str.substr(1, 5),
    &#39;week&#39;: v[&#39;l_shipdate&#39;].dt.week,
    &#39;year&#39;: v[&#39;l_shipdate&#39;].dt.year,
}, inplace=True).value
</pre></div>
</div>
<p>Note: Unlike a Pandas apply which executes the function for every row or column, MDataFrame will <strong>execute the function only once</strong> in order to build the database query. If you want to execute Python code row-by-row, or group-by-group, use <code class="docutils literal notranslate"><span class="pre">.tranform()</span></code>, see below.</p>
<section id="Parallel-transformations">
<h4>Parallel transformations<a class="headerlink" href="#Parallel-transformations" title="Link to this heading">¶</a></h4>
<p>MDataFrame supports in-parallel processing of arbitrary subsets and size of data. By default, the subset will be by row number, but any other grouping is possible.</p>
<p>The following snipped will start N / chunksize tasks and process them in parallel. Each task processes N / chunksize records. The default chunksize is 50’000. The number of parallel jobs started by default is CPU count - 1.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def myproc(df):
    df[&#39;column&#39;] = df[&#39;other&#39;].apply(...)

mdf.transform(myproc).persist(&#39;name&#39;, store=om.datasets)
</pre></div>
</div>
<p>More explanations:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def myproc(df, i):
    # df is the subset of the ith chunk of the full data
    # it is a Pandas in-memory DataFrame, apply any Pandas function you like
    # assignment is supported
    df[&#39;column&#39;] = df[&#39;other&#39;].apply(...)
    ...
    # groupby is also possible
    result = df.groupby(...)...
    # either return None (or no return statement) =&gt; updated df is written to the db
    # or return a DataFrame or a Series =&gt; returned object is written to the db
    return result

# this will start N = len(mdf) / 50&#39;000 tasks and store the results in om.datasets
# conceptually this is the equivalence of df = mdf.value.apply(myproc); om.datasets.put(df)
# however using mdf.transform() will use much less memory and easily scale out of core
mdf.transform(myproc).persist(&#39;name&#39;, store=om.datasets)

# specify chunksize and n_jobs to influence the number of chunks and the number of parallel workers.
# note this comes at a trade-off: many workers will take longer to complete, larger chunksizes will use more memory
mdf.transform(myproc, chunksize=&lt;#records&gt;, n_jobs=#numbers).persist(&#39;name&#39;, store=om.datasets)
</pre></div>
</div>
</section>
</section>
<section id="Customized-chunking">
<h3>Customized chunking<a class="headerlink" href="#Customized-chunking" title="Link to this heading">¶</a></h3>
<p>By default <code class="docutils literal notranslate"><span class="pre">.transform()</span></code> uses the size of the data (as in number of rows) do determine the number of chunks. You can however create any number chunks:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mdf = om.datasets.getl(&#39;retail&#39;)

def process(ldf):
    ldf[&#39;comments&#39;] = ldf[&#39;l_comment&#39;].str.split(&#39; &#39;)


def chunker(mdf, chunksize, maxobs):
    # for each chunk yield a MDataFrame subset for each chunk
    # note: don&#39;t use .value before yielding as this would resolve the dataframe locally
    #       and potentially consume all memory.
    groups = mdf[&#39;l_returnflag&#39;].unique().value
    for group in groups:
        for i in range(0, maxobs, chunksize):
            yield mdf.skip(i).head(chunksize).query(l_returnflag=group)

(mdf
 .transform(process, chunkfn=chunker, n_jobs=-2)
 .persist(&#39;retail-transformed&#39;, store=om.datasets))
</pre></div>
</div>
</section>
<section id="What-won't-work">
<h3>What won’t work<a class="headerlink" href="#What-won't-work" title="Link to this heading">¶</a></h3>
<p><em>MDataFrame are currently read-only. In other words, assignment, column additions and smilar operations are not currently supported. This is not an inherent restriction, there is just no API for it in the current implementation. Note if updates are required, the MDataFrame plugin mechanism provides a straight-forward way to provide such functionality.</em></p>
<p>Hence the following kind of operations are <strong>not currently supported</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mdf[col] = mdf[col].apply(func)
mdf[col] = mdf[col].map(func)
mdf[col] = value # partial support is available, but limited to scalar values
</pre></div>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025 (c) omegaml.io by one2seven GmbH.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>

      </div>
    </section>
  </div>
  <!-- version plugin for rtd template without sidebar -->
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: stable
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Tags</dt>
      <dd><a href="../../../latest/index.html" class="version-ref-latest">latest</a></dd>
      <dd><a href="../../../release/0.15.3/index.html" class="version-ref-release/0.15.3">0.15.3</a></dd>
      <dd><a href="../../../release/0.16.3/index.html" class="version-ref-release/0.16.3">0.16.3</a></dd>
      <dd><a href="../../../release/0.4/index.html" class="version-ref-release/0.4">0.4</a></dd>
      <dd><a href="../../../release/0.5/index.html" class="version-ref-release/0.5">0.5</a></dd>
      <dd><a href="omegaml-mdataframe-guide.html" class="version-ref-stable">stable</a></dd>
    </dl>
    <dl>
      <dt>Branches</dt>
      <dd><a href="../../../master/index.html">master</a></dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>